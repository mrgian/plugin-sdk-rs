#![allow(warnings)]
#![feature(pointer_byte_offsets)]
#![feature(ptr_sub_ptr)]

use const_format::formatcp;
use dbgtools_hexdump::{hexdump, Config};
use hex_literal::hex;
use rand::Rng;
use std::error::Error;
use std::ffi::*;

mod api;
use api::bindings::*;

mod common;
mod extract;
mod source;

mod plugin;
use plugin::{Common, Event, Extract, Plugin, Source};

#[derive(Debug)]
struct PluginState {
    sample_num: u64,
    remaining_events: u32,
    last_error: String,
    string_storage: String,
    string_storage2: String,
}

const dummy: Plugin = Plugin {
    name: "dummy-rs",
    description: "Falco dummy plugin written in Rust",
    contact: "Gianmatteo Palmieri <mail@gian.im>",
    version: "0.0.0",
    required_api_version: "3.0.0",
    event_source: "dummy-rs-source",
    id: 999,
};

static mut nevents: i32 = 0;

plugin_common!(dummy);
plugin_source!(dummy);
plugin_extract!(dummy);

impl Common for Plugin<'_> {
    fn init(&self) -> Box<PluginState> {
        println!("Initializing plugin...");

        let state = Box::new(PluginState {
            sample_num: 0,
            remaining_events: 10, //generate 10 events
            last_error: "".to_string(),
            string_storage: "".to_string(),
            string_storage2: "".to_string(),
        });

        state
    }

    fn destroy(&self, state: &mut PluginState) {
        println!("Destroying plugin...");
    }
}

impl Source for Plugin<'_> {
    fn open(&self, state: &mut PluginState) -> Result<(), String> {
        println!("Opening event stream...");

        //Err("Error while opening")
        Ok(())
    }

    fn close(&self, state: &mut PluginState) {
        println!("Closing event stream...");
    }

    fn next_batch(&self, state: &mut PluginState) -> Result<i32, String> {
        //setting num field to a random number, just to demonstrate you can get this form the state later
        let mut rng = rand::thread_rng();
        state.sample_num = rng.gen::<u64>();

        //generate 10 events
        if state.remaining_events == 0 {
            return Ok(-1); //SS_PLUGIN_TIMEOUT
        }

        state.remaining_events -= 1;

        Ok(0) //SS_PLUGIN_SUCCESS
    }
}

const fields_schema: &str = r#"
[
    {"type": "string","name": "sample.hello","desc": "An hello string"},
    {"type": "uint64","name": "sample.num","desc": "A random number generated by the event"}
]"#;
const FIELDS_SCHEMA: &str = formatcp!("{}\0", fields_schema);

impl Extract for Plugin<'_> {
    fn get_fields(&self) -> &str {
        FIELDS_SCHEMA
    }

    fn extract_fields(
        &self,
        state: &mut PluginState,
        fields: &mut [ss_plugin_extract_field],
    ) -> Result<(), String> {
        match fields[0].field_id {
            //sample.hello
            0 => {
                state.string_storage = format!("Hello field!");

                let mut hello_ptr = state.string_storage.as_ptr() as *const ::std::os::raw::c_char;
                fields[0].res.str_ = &mut hello_ptr as *mut *const ::std::os::raw::c_char;
                fields[0].res_len = 1;
            }

            //sample.num
            1 => {
                //get sample num from state
                fields[0].res.u64_ = &mut state.sample_num as *mut u64;
                fields[0].res_len = 1;
            }

            _ => {}
        }

        Ok(())
    }
}
