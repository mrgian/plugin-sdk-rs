use const_format::formatcp;
use rand::Rng;

use plugin_sdk_rs::bindings::*;
use plugin_sdk_rs::plugin::*;
use plugin_sdk_rs::plugin_common;
use plugin_sdk_rs::plugin_extract;
use plugin_sdk_rs::plugin_source;

#[derive(Debug)]
struct MyPluginState {
    sample_num: u64,
    remaining_events: u32,
    last_error: String,
    string_storage: String,
    string_storage2: String,
}

const dummy: Plugin = Plugin {
    name: "dummy-rs",
    description: "Falco dummy plugin written in Rust",
    contact: "Gianmatteo Palmieri <mail@gian.im>",
    version: "0.0.0",
    required_api_version: "3.0.0",
    event_source: "dummy-rs-source",
    id: 999,
};

static mut nevents: i32 = 0;

plugin_common!(dummy, MyPluginState);
plugin_source!(dummy, MyPluginState);
plugin_extract!(dummy, MyPluginState);

impl Common<MyPluginState> for Plugin<'_> {
    fn init(&self) -> Box<MyPluginState> {
        println!("Initializing plugin...");

        let state = Box::new(MyPluginState {
            sample_num: 0,
            remaining_events: 10, //generate 10 events
            last_error: "".to_string(),
            string_storage: "".to_string(),
            string_storage2: "".to_string(),
        });

        state
    }

    fn destroy(&self, _state: &mut MyPluginState) {
        println!("Destroying plugin...");
    }
}

impl Source<MyPluginState> for Plugin<'_> {
    fn open(&self, _state: &mut MyPluginState) -> Result<(), String> {
        println!("Opening event stream...");

        //Err("Error while opening")
        Ok(())
    }

    fn close(&self, _state: &mut MyPluginState) {
        println!("Closing event stream...");
    }

    fn next_batch(&self, state: &mut MyPluginState) -> Result<i32, String> {
        //setting num field to a random number, just to demonstrate you can get this form the state later
        let mut rng = rand::thread_rng();
        state.sample_num = rng.gen::<u64>();

        //generate 10 events
        if state.remaining_events == 0 {
            return Ok(-1); //SS_PLUGIN_TIMEOUT
        }

        state.remaining_events -= 1;

        Ok(0) //SS_PLUGIN_SUCCESS
    }
}

const fields_schema: &str = r#"
[
    {"type": "string","name": "sample.hello","desc": "An hello string"},
    {"type": "uint64","name": "sample.num","desc": "A random number generated by the event"}
]"#;
const FIELDS_SCHEMA: &str = formatcp!("{}\0", fields_schema);

impl Extract<MyPluginState> for Plugin<'_> {
    fn get_fields(&self) -> &str {
        FIELDS_SCHEMA
    }

    fn extract_fields(
        &self,
        state: &mut MyPluginState,
        fields: &mut [ss_plugin_extract_field],
    ) -> Result<(), String> {
        match fields[0].field_id {
            //sample.hello
            0 => {
                state.string_storage = format!("Hello field!");

                let mut hello_ptr = state.string_storage.as_ptr() as *const ::std::os::raw::c_char;
                fields[0].res.str_ = &mut hello_ptr as *mut *const ::std::os::raw::c_char;
                fields[0].res_len = 1;
            }

            //sample.num
            1 => {
                //get sample num from state
                fields[0].res.u64_ = &mut state.sample_num as *mut u64;
                fields[0].res_len = 1;
            }

            _ => {}
        }

        Ok(())
    }
}
