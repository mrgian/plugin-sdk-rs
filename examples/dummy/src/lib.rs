use const_format::formatcp;
use rand::Rng;

use plugin_sdk_rs::bindings::*;
use plugin_sdk_rs::plugin::*;
use plugin_sdk_rs::plugin_info;
use plugin_sdk_rs::plugin_common;
use plugin_sdk_rs::plugin_extract;
use plugin_sdk_rs::plugin_source;

#[derive(Debug)]
struct DummyState {
    sample_num: u64,
    remaining_events: u32,
    //last_error: String,
    string_storage: String,
    //string_storage2: String,
}

plugin_info!(
    "dummy",                                //name
    "Falco dummy plugin written in Rust",   //description
    "Gianmatteo Palmieri <mail@gian.im>",   //author
    "0.0.0",                                //version
    "3.0.0",                                //required api version
    "dummy-source",                         //event source
    999                                     //id
);

plugin_common!(DummyState);
plugin_source!(DummyState);
plugin_extract!(DummyState);

impl Common<DummyState> for Plugin<'_> {
    fn init(&self) -> Box<DummyState> {
        println!("Initializing plugin...");

        let state = Box::new(DummyState {
            sample_num: 0,
            remaining_events: 10, //generate 10 events
            //last_error: "".to_string(),
            string_storage: "".to_string(),
            //string_storage2: "".to_string(),
        });

        state
    }

    fn destroy(&self, _state: &mut DummyState) {
        println!("Destroying plugin...");
    }
}

impl Source<DummyState> for Plugin<'_> {
    fn open(&self, _state: &mut DummyState) -> Result<(), String> {
        println!("Opening event stream...");

        //Err("Error while opening")
        Ok(())
    }

    fn close(&self, _state: &mut DummyState) {
        println!("Closing event stream...");
    }

    fn next_batch(&self, state: &mut DummyState) -> Result<i32, String> {
        //setting num field to a random number, just to demonstrate you can get this form the state later
        let mut rng = rand::thread_rng();
        state.sample_num = rng.gen::<u64>();

        //generate 10 events
        if state.remaining_events == 0 {
            return Ok(-1); //SS_PLUGIN_TIMEOUT
        }

        state.remaining_events -= 1;

        Ok(0) //SS_PLUGIN_SUCCESS
    }
}

const FIELDS_SCHEMA: &str = r#"
[
    {"type": "string","name": "sample.hello","desc": "An hello string"},
    {"type": "uint64","name": "sample.num","desc": "A random number generated by the event"}
]"#;

impl Extract<DummyState> for Plugin<'_> {
    fn get_fields(&self) -> &str {
        FIELDS_SCHEMA
    }

    fn extract_fields(
        &self,
        state: &mut DummyState,
        fields: &mut [ss_plugin_extract_field],
    ) -> Result<(), String> {
        match fields[0].field_id {
            //sample.hello
            0 => {
                state.string_storage = format!("Hello field!");

                let mut hello_ptr = state.string_storage.as_ptr() as *const ::std::os::raw::c_char;
                fields[0].res.str_ = &mut hello_ptr as *mut *const ::std::os::raw::c_char;
                fields[0].res_len = 1;
            }

            //sample.num
            1 => {
                //get sample num from state
                fields[0].res.u64_ = &mut state.sample_num as *mut u64;
                fields[0].res_len = 1;
            }

            _ => {}
        }

        Ok(())
    }
}
